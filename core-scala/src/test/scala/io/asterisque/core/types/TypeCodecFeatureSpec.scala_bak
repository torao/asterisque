/*
 * Copyright (c) 2014 koiroha.org.
 * All sources and related resources are available under Apache License 2.0.
 * http://www.apache.org/licenses/LICENSE-2.0.html
*/
package io.asterisque.core.types

import java.lang.{Boolean => JBoolean, Byte => JByte, Character => JChar, Double => JDouble, Float => JFloat, Integer => JInt, Long => JLong, Short => JShort}
import java.util
import java.util.{Collections, UUID}

import io.asterisque.core.Tuple
import io.asterisque.core.codec._
import org.specs2.Specification
import org.specs2.execute.Result
import org.specs2.matcher.MatchResult

import scala.collection.JavaConversions._
import scala.collection.JavaConverters
import scala.util.Random

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// TypeCodecFeatureSpec
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/**
  * @author Takami Torao
  */
class TypeCodecFeatureSpec extends Specification {
  def is =
    s2"""
TypeCodecFeature should:
have default transfer-safe types. $e0
convert same value for transfer-safe types. $restorationByRetransformation
not convert for default supported type. $e1
convert for default known type. $e2
convert parameter to call method. $e3
convert parameter implicitly for different type. $e4
transform null to zero-value for primitive types. $e5
convert Java transferable values to call method type. $e6
convert Scala transferable values to call method type. $e7
convert standard or Scala tuple and case class values. $e8
"""

  private[this] val conv = new TypeCodecFeature()

  private[this] def e0:MatchResult[_] = Seq(
      null:Class[_],
      classOf[java.lang.Void],
      classOf[java.lang.Boolean],
      classOf[java.lang.Byte],
      classOf[java.lang.Short],
      classOf[java.lang.Integer],
      classOf[java.lang.Long],
      classOf[java.lang.Float],
      classOf[java.lang.Double],
      classOf[Array[Byte]],
      classOf[String],
      classOf[java.util.UUID],
      classOf[java.util.List[_]],
      classOf[java.util.Map[_, _]],
      classOf[Tuple]
    ).map { t => TypeCodecFeature.isDefaultSafeType(t) must beTrue }.reduce {
      _ and _
  }

  private[this] def restorationByRetransformation:Result = {

    def ep(expected:Any, clazz:Class[_ <: Any]) = {
      conv.transferableToJava(conv.javaToTransferable(expected).get(), clazz).get() === expected
    }

    def ea[T](expected:Array[T], clazz:Class[_ <: Any]) = {
      conv.transferableToJava(conv.javaToTransferable(expected).get(), clazz).get() match {
        case actual:Array[T] =>
          actual.toList.zip(expected.toList).map { case (a, b) => a === b }.fold(True) {
            _ and _
          }
      }
    }

    val r = new Random()
    // Java Object
    Seq[Result](
      ep(null, classOf[Object]),
      ep(true, classOf[java.lang.Boolean]),
      ep(false, classOf[java.lang.Boolean]),
      ep(Byte.box(r.nextInt().toByte), classOf[java.lang.Byte]),
      ep(Short.box(r.nextInt().toShort), classOf[java.lang.Short]),
      ep(Int.box(r.nextInt()), classOf[Integer]),
      ep(Long.box(r.nextLong()), classOf[java.lang.Long]),
      ep(Float.box(r.nextFloat()), classOf[java.lang.Float]),
      ep(Double.box(r.nextDouble()), classOf[java.lang.Double]),
      ea((0 to 255).map { _ => r.nextInt().toByte }.toArray, classOf[Array[Byte]]),
      ep(new String((0 to 255).map { _ => ('A' + r.nextInt('Z' - 'A')).toChar }.toArray), classOf[String]),
      ep(UUID.randomUUID(), classOf[UUID]),
      {
        val expected = util.Arrays.asList(1, "A")
        conv.transferableToJava(conv.javaToTransferable(expected).get(), classOf[util.List[_]]).get() match {
          case actual:java.util.List[_] =>
            actual.toList.zip(expected.toList).map { case (a, b) => a === b }.fold(True) {
              _ and _
            }
        }
      }, {
        val expected = new util.HashSet(util.Arrays.asList(1, "A"))
        conv.transferableToJava(conv.javaToTransferable(expected).get(), classOf[util.Set[_]]).get() match {
          case actual:java.util.Set[_] =>
            (actual.toSet -- expected.toSet).size === 0
        }
      }, {
        val expected = JavaConverters.mapAsJavaMap(Map(1 -> 2, "A" -> "B"))
        conv.transferableToJava(conv.javaToTransferable(expected).get(), classOf[util.Map[_, _]]).get() match {
          case actual:java.util.Map[_, _] =>
            actual.size === expected.size and
              actual.keys.map { k => actual.get(k) === expected.get(k) }.fold(True) {
                _ and _
              }
        }
      },
      // Scala Object
      // ep((), classOf[Unit]),     // classOf[Unit] == Void.TYPE のため () -> null -> null となり対称性がない
      ep(true, classOf[Boolean]),
      ep(false, classOf[Boolean]),
      ep(r.nextInt().toByte, classOf[Byte]),
      ep(r.nextInt().toShort, classOf[Short]),
      ep(r.nextInt(), classOf[Int]),
      ep(r.nextLong(), classOf[Long]),
      ep(r.nextFloat(), classOf[Float]),
      ep(r.nextDouble(), classOf[Double]),
      {
        val expected = List(1, "A")
        conv.transferableToJava(conv.javaToTransferable(expected).get(), classOf[List[_]]).get() match {
          case actual:List[Any] =>
            actual.zip(expected).map { case (a, b) => a === b }.fold(True) {
              _ and _
            }
        }
      }, {
        val expected = Set("A", "B", "A", "C")
        conv.transferableToJava(conv.javaToTransferable(expected).get(), classOf[Set[_]]).get() match {
          case actual:Set[String] =>
            actual.&~(expected).size === 0
        }
      }, {
        val expected = Map(1 -> 2, "A" -> "B")
        conv.transferableToJava(conv.javaToTransferable(expected).get(), classOf[Map[_, _]]).get() match {
          case actual:Map[_, _] =>
            actual.size === expected.size and
              actual.keys.map { k => actual.get(k) === expected.get(k) }.fold(True) {
                _ and _
              }
        }
      }
    ).reduce {
      _ and _
    }
  }

  def e1:Result = {
    def f(value:AnyRef, expected:Class[_]) = {
      expected.isAssignableFrom(conv.javaToTransferable(value).get().getClass) must beTrue
    }

    (conv.javaToTransferable(null).get() === null) and
      tp(Boolean.box(true), java.lang.Boolean.TRUE) and
      f(Byte.box(0), classOf[java.lang.Byte]) and
      f(Short.box(0), classOf[java.lang.Short]) and
      f(Int.box(0), classOf[java.lang.Integer]) and
      f(Long.box(0), classOf[java.lang.Long]) and
      f(Float.box(0), classOf[java.lang.Float]) and
      f(Double.box(0), classOf[java.lang.Double]) and
      f(Array[Byte](), classOf[Array[Byte]]) and
      f("", classOf[String]) and
      f(UUID.randomUUID(), classOf[UUID]) and
      f(Collections.emptyList(), classOf[java.util.List[_]]) and
      f(Collections.emptyMap(), classOf[java.util.Map[_, _]]) and
      f(new Tuple {
        override def count():Int = 0

        override def schema():String = ""

        override def valueAt(i:Int):AnyRef = None
      }, classOf[Tuple])
  }

  private[this] def e2 = {
    def f(value:AnyRef, expected:Class[_]) = {
      expected.isAssignableFrom(conv.javaToTransferable(value).get().getClass) must beTrue
    }

    val obj = new Object()
    Seq(
      // Java Standard
      ts(Char.box('A'), "A"),
      tl(Array[AnyRef](obj, "hoge"), List(obj, "hoge")),
      tl(Array[Boolean](true, false), List(true, false)),
      tl(Array[Short](0.toShort, 1.toShort), List(0.toShort, 1.toShort)),
      tl(Array(0, 1), List(0, 1)),
      tl(Array(0.toLong, 1.toLong), List(0.toLong, 1.toLong)),
      tl(Array(0.toFloat, 1.toFloat), List(0.toFloat, 1.toFloat)),
      tl(Array(0.toDouble, 1.toDouble), List(0.toDouble, 1.toDouble)),
      ts("ABC".toCharArray, "ABC"),
      tl(new java.util.TreeSet[Int]() {
        add(0);
        add(1)
      }, List(0, 1)),
      // Scala Extension
      tl(Seq(0, 1, 2), List(0, 1, 2)),
      tl(List(0, 1, 2), List(0, 1, 2)),
      tm(Map(0 -> 1, "A" -> "B"), Map(0 -> 1, "A" -> "B")),
      tp(true, java.lang.Boolean.TRUE),
      tp(0.toByte, java.lang.Byte.valueOf(0.toByte)),
      tp(0.toShort, java.lang.Short.valueOf(0.toShort)),
      tp(0, java.lang.Integer.valueOf(0)),
      tp(0.toLong, java.lang.Long.valueOf(0.toLong)),
      tp(0.toFloat, java.lang.Float.valueOf(0.toFloat)),
      tp(0.toDouble, java.lang.Double.valueOf(0.toDouble))
    ).reduce (_ and _)
  }

  def e3:Result = {
    mp("A", classOf[Character], 'A') and
      mp("", classOf[Character], '\0') and
      mp("ABC", classOf[Character], 'A') and
      mp("\u0378", classOf[Character], '\u0378') and // Undefined Unicode
      ma("A", classOf[Array[Char]], List('A')) and
      ma("ABC", classOf[Array[Char]], List('A', 'B', 'C')) and
      ma("", classOf[Array[Char]], List()) and
      success
  }

  def e4:Result = {
    (conv.transferableToJava(true, classOf[JByte]).get() === 1.toByte) and
      success
  }

  def tp[T](value:Any, expected:T):Result = {
    conv.javaToTransferable(value).get() match {
      case actual:T => actual === expected
    }
  }

  def mp[T](value:Any, clazz:Class[_ <: Any], expected:T):Result = {
    conv.transferableToJava(value, clazz).get() match {
      case actual:T => actual === expected
    }
  }

  def ts(value:AnyRef, expected:String):Result = {
    conv.javaToTransferable(value).get() match {
      case actual:String => actual === expected
    }
  }

  def ma[T](value:Any, clazz:Class[_ <: Any], expected:List[T]):Result = {
    conv.transferableToJava(value, clazz).get() match {
      case actual:Array[T] =>
        actual.toList.zip(expected).map { case (a, b) => a === b }.fold(True) {
          _ and _
        }
    }
  }

  def tl(value:Any, expected:List[_]):Result = {
    conv.javaToTransferable(value).get() match {
      case actual:java.util.List[_] =>
        actual.zip(expected).map { case (a, b) => a === b }.fold(True) {
          _ and _
        }
      case u =>
        System.err.println(s"unexpected list type: $u")
        true must beFalse
    }
  }

  def tm(value:AnyRef, expected:Map[Any, _]):Result = {
    conv.javaToTransferable(value).get() match {
      case actual:java.util.Map[_, _] =>
        (actual.keySet().toSet -- expected.keySet).size === 0 and
          expected.keySet.map { k => actual.get(k) === expected(k) }.fold(True) {
            _ and _
          }
    }
  }

  def e5:MatchResult[_] = Seq(
    conv.transferableToJava(null, classOf[Object]).get() === null,
    conv.transferableToJava(null, java.lang.Void.TYPE).get() === null,
    conv.transferableToJava(null, JBoolean.TYPE).get() === false,
    conv.transferableToJava(null, JByte.TYPE).get() === 0.toByte,
    conv.transferableToJava(null, JShort.TYPE).get() === 0.toShort,
    conv.transferableToJava(null, JInt.TYPE).get() === 0,
    conv.transferableToJava(null, JLong.TYPE).get() === 0.toLong,
    conv.transferableToJava(null, JFloat.TYPE).get() === 0.toFloat,
    conv.transferableToJava(null, JDouble.TYPE).get() === 0.toDouble,
    conv.transferableToJava(null, JChar.TYPE).get() === '\0',
    True
  ).reduce(_ and _)

  def e6:MatchResult[_] = Seq(
    conv.transferableToJava(null, classOf[Void]).get() === null,
    // boolean の数値評価は C と同じ
    conv.transferableToJava(JBoolean.TRUE, classOf[JByte]).get() !== 0,
    conv.transferableToJava(JBoolean.FALSE, classOf[JByte]).get() === 0,
    conv.transferableToJava(JBoolean.TRUE, classOf[JShort]).get() !== 0,
    conv.transferableToJava(JBoolean.FALSE, classOf[JShort]).get() === 0,
    conv.transferableToJava(JBoolean.TRUE, classOf[JInt]).get() !== 0,
    conv.transferableToJava(JBoolean.FALSE, classOf[JInt]).get() === 0,
    conv.transferableToJava(JBoolean.TRUE, classOf[JLong]).get() !== 0,
    conv.transferableToJava(JBoolean.FALSE, classOf[JLong]).get() === 0,
    conv.transferableToJava(JBoolean.TRUE, classOf[JFloat]).get() !== 0,
    conv.transferableToJava(JBoolean.FALSE, classOf[JFloat]).get() === 0,
    conv.transferableToJava(JBoolean.TRUE, classOf[JDouble]).get() !== 0,
    conv.transferableToJava(JBoolean.FALSE, classOf[JDouble]).get() === 0,
    conv.transferableToJava(JBoolean.TRUE, classOf[String]).get() === "true",
    conv.transferableToJava(JBoolean.FALSE, classOf[String]).get() === "false",
    // byte
    conv.transferableToJava(0.toByte, classOf[JBoolean]).get() === false,
    conv.transferableToJava(1.toByte, classOf[JBoolean]).get() === true,
    conv.transferableToJava(Byte.MaxValue, classOf[JShort]).get() === Byte.MaxValue.toShort,
    conv.transferableToJava(Byte.MinValue, classOf[JShort]).get() === Byte.MinValue.toShort,
    conv.transferableToJava(Byte.MaxValue, classOf[JInt]).get() === Byte.MaxValue.toInt,
    conv.transferableToJava(Byte.MinValue, classOf[JInt]).get() === Byte.MinValue.toInt,
    conv.transferableToJava(Byte.MaxValue, classOf[JLong]).get() === Byte.MaxValue.toLong,
    conv.transferableToJava(Byte.MinValue, classOf[JLong]).get() === Byte.MinValue.toLong,
    conv.transferableToJava(Byte.MaxValue, classOf[JFloat]).get() === Byte.MaxValue.toFloat,
    conv.transferableToJava(Byte.MinValue, classOf[JFloat]).get() === Byte.MinValue.toFloat,
    conv.transferableToJava(Byte.MaxValue, classOf[JDouble]).get() === Byte.MaxValue.toDouble,
    conv.transferableToJava(Byte.MinValue, classOf[JDouble]).get() === Byte.MinValue.toDouble,
    conv.transferableToJava(Byte.MaxValue, classOf[String]).get() === Byte.MaxValue.toString,
    conv.transferableToJava(Byte.MinValue, classOf[String]).get() === Byte.MinValue.toString,
    // short
    conv.transferableToJava(0.toShort, classOf[JBoolean]).get() === false,
    conv.transferableToJava(1.toShort, classOf[JBoolean]).get() === true,
    conv.transferableToJava(Short.MaxValue, classOf[JShort]).get() === Short.MaxValue.toShort,
    conv.transferableToJava(Short.MinValue, classOf[JShort]).get() === Short.MinValue.toShort,
    conv.transferableToJava(Short.MaxValue, classOf[JInt]).get() === Short.MaxValue.toInt,
    conv.transferableToJava(Short.MinValue, classOf[JInt]).get() === Short.MinValue.toInt,
    conv.transferableToJava(Short.MaxValue, classOf[JLong]).get() === Short.MaxValue.toLong,
    conv.transferableToJava(Short.MinValue, classOf[JLong]).get() === Short.MinValue.toLong,
    conv.transferableToJava(Short.MaxValue, classOf[JFloat]).get() === Short.MaxValue.toFloat,
    conv.transferableToJava(Short.MinValue, classOf[JFloat]).get() === Short.MinValue.toFloat,
    conv.transferableToJava(Short.MaxValue, classOf[JDouble]).get() === Short.MaxValue.toDouble,
    conv.transferableToJava(Short.MinValue, classOf[JDouble]).get() === Short.MinValue.toDouble,
    conv.transferableToJava(Short.MaxValue, classOf[String]).get() === Short.MaxValue.toString,
    conv.transferableToJava(Short.MinValue, classOf[String]).get() === Short.MinValue.toString,
    // int
    conv.transferableToJava(0.toInt, classOf[JBoolean]).get() === false,
    conv.transferableToJava(1.toInt, classOf[JBoolean]).get() === true,
    conv.transferableToJava(Int.MaxValue, classOf[JShort]).get() === Int.MaxValue.toShort,
    conv.transferableToJava(Int.MinValue, classOf[JShort]).get() === Int.MinValue.toShort,
    conv.transferableToJava(Int.MaxValue, classOf[JInt]).get() === Int.MaxValue.toInt,
    conv.transferableToJava(Int.MinValue, classOf[JInt]).get() === Int.MinValue.toInt,
    conv.transferableToJava(Int.MaxValue, classOf[JLong]).get() === Int.MaxValue.toLong,
    conv.transferableToJava(Int.MinValue, classOf[JLong]).get() === Int.MinValue.toLong,
    conv.transferableToJava(Int.MaxValue, classOf[JFloat]).get() === Int.MaxValue.toFloat,
    conv.transferableToJava(Int.MinValue, classOf[JFloat]).get() === Int.MinValue.toFloat,
    conv.transferableToJava(Int.MaxValue, classOf[JDouble]).get() === Int.MaxValue.toDouble,
    conv.transferableToJava(Int.MinValue, classOf[JDouble]).get() === Int.MinValue.toDouble,
    conv.transferableToJava(Int.MaxValue, classOf[String]).get() === Int.MaxValue.toString,
    conv.transferableToJava(Int.MinValue, classOf[String]).get() === Int.MinValue.toString,
    // long
    conv.transferableToJava(0.toLong, classOf[JBoolean]).get() === false,
    conv.transferableToJava(1.toLong, classOf[JBoolean]).get() === true,
    conv.transferableToJava(Long.MaxValue, classOf[JShort]).get() === Long.MaxValue.toShort,
    conv.transferableToJava(Long.MinValue, classOf[JShort]).get() === Long.MinValue.toShort,
    conv.transferableToJava(Long.MaxValue, classOf[JInt]).get() === Long.MaxValue.toInt,
    conv.transferableToJava(Long.MinValue, classOf[JInt]).get() === Long.MinValue.toInt,
    conv.transferableToJava(Long.MaxValue, classOf[JLong]).get() === Long.MaxValue.toLong,
    conv.transferableToJava(Long.MinValue, classOf[JLong]).get() === Long.MinValue.toLong,
    conv.transferableToJava(Long.MaxValue, classOf[JFloat]).get() === Long.MaxValue.toFloat,
    conv.transferableToJava(Long.MinValue, classOf[JFloat]).get() === Long.MinValue.toFloat,
    conv.transferableToJava(Long.MaxValue, classOf[JDouble]).get() === Long.MaxValue.toDouble,
    conv.transferableToJava(Long.MinValue, classOf[JDouble]).get() === Long.MinValue.toDouble,
    conv.transferableToJava(Long.MaxValue, classOf[String]).get() === Long.MaxValue.toString,
    conv.transferableToJava(Long.MinValue, classOf[String]).get() === Long.MinValue.toString,
    // float
    // TODO NaN, Infinite のテスト
    conv.transferableToJava(0.toFloat, classOf[JBoolean]).get() === false,
    conv.transferableToJava(1.toFloat, classOf[JBoolean]).get() === true,
    conv.transferableToJava(Float.MaxValue, classOf[JShort]).get() === Float.MaxValue.toShort,
    conv.transferableToJava(Float.MinValue, classOf[JShort]).get() === Float.MinValue.toShort,
    conv.transferableToJava(Float.MaxValue, classOf[JInt]).get() === Float.MaxValue.toInt,
    conv.transferableToJava(Float.MinValue, classOf[JInt]).get() === Float.MinValue.toInt,
    conv.transferableToJava(Float.MaxValue, classOf[JLong]).get() === Float.MaxValue.toLong,
    conv.transferableToJava(Float.MinValue, classOf[JLong]).get() === Float.MinValue.toLong,
    conv.transferableToJava(Float.MaxValue, classOf[JFloat]).get() === Float.MaxValue.toFloat,
    conv.transferableToJava(Float.MinValue, classOf[JFloat]).get() === Float.MinValue.toFloat,
    conv.transferableToJava(Float.MaxValue, classOf[JDouble]).get() === Float.MaxValue.toDouble,
    conv.transferableToJava(Float.MinValue, classOf[JDouble]).get() === Float.MinValue.toDouble,
    conv.transferableToJava(Float.MaxValue, classOf[String]).get() === Float.MaxValue.toString,
    conv.transferableToJava(Float.MinValue, classOf[String]).get() === Float.MinValue.toString,
    // double
    // TODO NaN, Infinite のテスト
    conv.transferableToJava(0.toDouble, classOf[JBoolean]).get() === false,
    conv.transferableToJava(1.toDouble, classOf[JBoolean]).get() === true,
    conv.transferableToJava(Double.MaxValue, classOf[JShort]).get() === Double.MaxValue.toShort,
    conv.transferableToJava(Double.MinValue, classOf[JShort]).get() === Double.MinValue.toShort,
    conv.transferableToJava(Double.MaxValue, classOf[JInt]).get() === Double.MaxValue.toInt,
    conv.transferableToJava(Double.MinValue, classOf[JInt]).get() === Double.MinValue.toInt,
    conv.transferableToJava(Double.MaxValue, classOf[JLong]).get() === Double.MaxValue.toLong,
    conv.transferableToJava(Double.MinValue, classOf[JLong]).get() === Double.MinValue.toLong,
    conv.transferableToJava(Double.NaN, classOf[JLong]).get() === Double.NaN.toLong,
    conv.transferableToJava(Double.PositiveInfinity, classOf[JLong]).get() === Double.PositiveInfinity.toLong,
    conv.transferableToJava(Double.NegativeInfinity, classOf[JLong]).get() === Double.NegativeInfinity.toLong,
    conv.transferableToJava(Double.MaxValue, classOf[JFloat]).get() === Double.MaxValue.toFloat,
    conv.transferableToJava(Double.MinValue, classOf[JFloat]).get() === Double.MinValue.toFloat,
    JFloat.isNaN(conv.transferableToJava(Double.NaN, classOf[JFloat]).get()) must beTrue,
    JFloat.isInfinite(conv.transferableToJava(Double.PositiveInfinity, classOf[JFloat]).get()) must beTrue,
    JFloat.isInfinite(conv.transferableToJava(Double.NegativeInfinity, classOf[JFloat]).get()) must beTrue,
    conv.transferableToJava(Double.MaxValue, classOf[JDouble]).get() === Double.MaxValue.toDouble,
    conv.transferableToJava(Double.MinValue, classOf[JDouble]).get() === Double.MinValue.toDouble,
    JDouble.isNaN(conv.transferableToJava(Double.NaN, classOf[JDouble]).get()) must beTrue,
    JDouble.isInfinite(conv.transferableToJava(Double.PositiveInfinity, classOf[JDouble]).get()) must beTrue,
    JDouble.isInfinite(conv.transferableToJava(Double.NegativeInfinity, classOf[JDouble]).get()) must beTrue,
    conv.transferableToJava(Double.MaxValue, classOf[String]).get() === Double.MaxValue.toString,
    conv.transferableToJava(Double.MinValue, classOf[String]).get() === Double.MinValue.toString,
    // String
    conv.transferableToJava("false", classOf[JBoolean]).get() === false,
    conv.transferableToJava("true", classOf[JBoolean]).get() === true,
    conv.transferableToJava(Short.MaxValue.toString, classOf[JShort]).get() === Short.MaxValue,
    conv.transferableToJava(Short.MinValue.toString, classOf[JShort]).get() === Short.MinValue,
    conv.transferableToJava(Int.MaxValue.toString, classOf[JInt]).get() === Int.MaxValue,
    conv.transferableToJava(Int.MinValue.toString, classOf[JInt]).get() === Int.MinValue,
    conv.transferableToJava(Long.MaxValue.toString, classOf[JLong]).get() === Long.MaxValue,
    conv.transferableToJava(Long.MinValue.toString, classOf[JLong]).get() === Long.MinValue,
    conv.transferableToJava(Float.MaxValue.toString, classOf[JFloat]).get() === Float.MaxValue,
    conv.transferableToJava(Float.MinValue.toString, classOf[JFloat]).get() === Float.MinValue,
    conv.transferableToJava(Double.MaxValue.toString, classOf[JDouble]).get() === Double.MaxValue,
    conv.transferableToJava(Double.MinValue.toString, classOf[JDouble]).get() === Double.MinValue,
    conv.transferableToJava(RandomUUID.toString, classOf[UUID]).get() === RandomUUID,
    // UUID
    conv.transferableToJava(RandomUUID, classOf[String]).get() === RandomUUID.toString,
    True
  ).reduce(_ and _)

  def e7:MatchResult[_] = Seq(
    conv.transferableToJava(null, classOf[Unit]).get() === (),
    // boolean の数値評価は C と同じ
    conv.transferableToJava(true, classOf[Byte]).get() !== 0,
    conv.transferableToJava(false, classOf[Byte]).get() === 0,
    conv.transferableToJava(true, classOf[Short]).get() !== 0,
    conv.transferableToJava(false, classOf[Short]).get() === 0,
    conv.transferableToJava(true, classOf[Int]).get() !== 0,
    conv.transferableToJava(false, classOf[Int]).get() === 0,
    conv.transferableToJava(true, classOf[Long]).get() !== 0,
    conv.transferableToJava(false, classOf[Long]).get() === 0,
    conv.transferableToJava(true, classOf[Float]).get() !== 0,
    conv.transferableToJava(false, classOf[Float]).get() === 0,
    conv.transferableToJava(true, classOf[Double]).get() !== 0,
    conv.transferableToJava(false, classOf[Double]).get() === 0,
    // byte
    conv.transferableToJava(0.toByte, classOf[Boolean]).get() === false,
    conv.transferableToJava(1.toByte, classOf[Boolean]).get() === true,
    conv.transferableToJava(Byte.MaxValue, classOf[Short]).get() === Byte.MaxValue.toShort,
    conv.transferableToJava(Byte.MinValue, classOf[Short]).get() === Byte.MinValue.toShort,
    conv.transferableToJava(Byte.MaxValue, classOf[Int]).get() === Byte.MaxValue.toInt,
    conv.transferableToJava(Byte.MinValue, classOf[Int]).get() === Byte.MinValue.toInt,
    conv.transferableToJava(Byte.MaxValue, classOf[Long]).get() === Byte.MaxValue.toLong,
    conv.transferableToJava(Byte.MinValue, classOf[Long]).get() === Byte.MinValue.toLong,
    conv.transferableToJava(Byte.MaxValue, classOf[Float]).get() === Byte.MaxValue.toFloat,
    conv.transferableToJava(Byte.MinValue, classOf[Float]).get() === Byte.MinValue.toFloat,
    conv.transferableToJava(Byte.MaxValue, classOf[Double]).get() === Byte.MaxValue.toDouble,
    conv.transferableToJava(Byte.MinValue, classOf[Double]).get() === Byte.MinValue.toDouble,
    // short
    conv.transferableToJava(0.toShort, classOf[Boolean]).get() === false,
    conv.transferableToJava(1.toShort, classOf[Boolean]).get() === true,
    conv.transferableToJava(Short.MaxValue, classOf[Short]).get() === Short.MaxValue.toShort,
    conv.transferableToJava(Short.MinValue, classOf[Short]).get() === Short.MinValue.toShort,
    conv.transferableToJava(Short.MaxValue, classOf[Int]).get() === Short.MaxValue.toInt,
    conv.transferableToJava(Short.MinValue, classOf[Int]).get() === Short.MinValue.toInt,
    conv.transferableToJava(Short.MaxValue, classOf[Long]).get() === Short.MaxValue.toLong,
    conv.transferableToJava(Short.MinValue, classOf[Long]).get() === Short.MinValue.toLong,
    conv.transferableToJava(Short.MaxValue, classOf[Float]).get() === Short.MaxValue.toFloat,
    conv.transferableToJava(Short.MinValue, classOf[Float]).get() === Short.MinValue.toFloat,
    conv.transferableToJava(Short.MaxValue, classOf[Double]).get() === Short.MaxValue.toDouble,
    conv.transferableToJava(Short.MinValue, classOf[Double]).get() === Short.MinValue.toDouble,
    // int
    conv.transferableToJava(0.toInt, classOf[Boolean]).get() === false,
    conv.transferableToJava(1.toInt, classOf[Boolean]).get() === true,
    conv.transferableToJava(Int.MaxValue, classOf[Short]).get() === Int.MaxValue.toShort,
    conv.transferableToJava(Int.MinValue, classOf[Short]).get() === Int.MinValue.toShort,
    conv.transferableToJava(Int.MaxValue, classOf[Int]).get() === Int.MaxValue.toInt,
    conv.transferableToJava(Int.MinValue, classOf[Int]).get() === Int.MinValue.toInt,
    conv.transferableToJava(Int.MaxValue, classOf[Long]).get() === Int.MaxValue.toLong,
    conv.transferableToJava(Int.MinValue, classOf[Long]).get() === Int.MinValue.toLong,
    conv.transferableToJava(Int.MaxValue, classOf[Float]).get() === Int.MaxValue.toFloat,
    conv.transferableToJava(Int.MinValue, classOf[Float]).get() === Int.MinValue.toFloat,
    conv.transferableToJava(Int.MaxValue, classOf[Double]).get() === Int.MaxValue.toDouble,
    conv.transferableToJava(Int.MinValue, classOf[Double]).get() === Int.MinValue.toDouble,
    // long
    conv.transferableToJava(0.toLong, classOf[Boolean]).get() === false,
    conv.transferableToJava(1.toLong, classOf[Boolean]).get() === true,
    conv.transferableToJava(Long.MaxValue, classOf[Short]).get() === Long.MaxValue.toShort,
    conv.transferableToJava(Long.MinValue, classOf[Short]).get() === Long.MinValue.toShort,
    conv.transferableToJava(Long.MaxValue, classOf[Int]).get() === Long.MaxValue.toInt,
    conv.transferableToJava(Long.MinValue, classOf[Int]).get() === Long.MinValue.toInt,
    conv.transferableToJava(Long.MaxValue, classOf[Long]).get() === Long.MaxValue.toLong,
    conv.transferableToJava(Long.MinValue, classOf[Long]).get() === Long.MinValue.toLong,
    conv.transferableToJava(Long.MaxValue, classOf[Float]).get() === Long.MaxValue.toFloat,
    conv.transferableToJava(Long.MinValue, classOf[Float]).get() === Long.MinValue.toFloat,
    conv.transferableToJava(Long.MaxValue, classOf[Double]).get() === Long.MaxValue.toDouble,
    conv.transferableToJava(Long.MinValue, classOf[Double]).get() === Long.MinValue.toDouble,
    // float
    // TODO NaN, Infinite のテスト
    conv.transferableToJava(0.toFloat, classOf[Boolean]).get() === false,
    conv.transferableToJava(1.toFloat, classOf[Boolean]).get() === true,
    conv.transferableToJava(Float.MaxValue, classOf[Short]).get() === Float.MaxValue.toShort,
    conv.transferableToJava(Float.MinValue, classOf[Short]).get() === Float.MinValue.toShort,
    conv.transferableToJava(Float.MaxValue, classOf[Int]).get() === Float.MaxValue.toInt,
    conv.transferableToJava(Float.MinValue, classOf[Int]).get() === Float.MinValue.toInt,
    conv.transferableToJava(Float.MaxValue, classOf[Long]).get() === Float.MaxValue.toLong,
    conv.transferableToJava(Float.MinValue, classOf[Long]).get() === Float.MinValue.toLong,
    conv.transferableToJava(Float.MaxValue, classOf[Float]).get() === Float.MaxValue.toFloat,
    conv.transferableToJava(Float.MinValue, classOf[Float]).get() === Float.MinValue.toFloat,
    conv.transferableToJava(Float.MaxValue, classOf[Double]).get() === Float.MaxValue.toDouble,
    conv.transferableToJava(Float.MinValue, classOf[Double]).get() === Float.MinValue.toDouble,
    // double
    // TODO NaN, Infinite のテスト
    conv.transferableToJava(0.toDouble, classOf[Boolean]).get() === false,
    conv.transferableToJava(1.toDouble, classOf[Boolean]).get() === true,
    conv.transferableToJava(Double.MaxValue, classOf[Short]).get() === Double.MaxValue.toShort,
    conv.transferableToJava(Double.MinValue, classOf[Short]).get() === Double.MinValue.toShort,
    conv.transferableToJava(Double.MaxValue, classOf[Int]).get() === Double.MaxValue.toInt,
    conv.transferableToJava(Double.MinValue, classOf[Int]).get() === Double.MinValue.toInt,
    conv.transferableToJava(Double.MaxValue, classOf[Long]).get() === Double.MaxValue.toLong,
    conv.transferableToJava(Double.MinValue, classOf[Long]).get() === Double.MinValue.toLong,
    conv.transferableToJava(Double.NaN, classOf[Long]).get() === Double.NaN.toLong,
    conv.transferableToJava(Double.PositiveInfinity, classOf[Long]).get() === Double.PositiveInfinity.toLong,
    conv.transferableToJava(Double.NegativeInfinity, classOf[Long]).get() === Double.NegativeInfinity.toLong,
    conv.transferableToJava(Double.MaxValue, classOf[Float]).get() === Double.MaxValue.toFloat,
    conv.transferableToJava(Double.MinValue, classOf[Float]).get() === Double.MinValue.toFloat,
    conv.transferableToJava(Double.NaN, classOf[Float]).get().isNaN must beTrue,
    conv.transferableToJava(Double.PositiveInfinity, classOf[Float]).get() === Float.PositiveInfinity,
    conv.transferableToJava(Double.NegativeInfinity, classOf[Float]).get() === Float.NegativeInfinity,
    conv.transferableToJava(Double.MaxValue, classOf[Double]).get() === Double.MaxValue.toDouble,
    conv.transferableToJava(Double.MinValue, classOf[Double]).get() === Double.MinValue.toDouble,
    conv.transferableToJava(Double.NaN, classOf[Double]).get().isNaN must beTrue,
    conv.transferableToJava(Double.PositiveInfinity, classOf[Double]).get() === Double.PositiveInfinity,
    conv.transferableToJava(Double.NegativeInfinity, classOf[Double]).get() === Double.NegativeInfinity,
    // String
    conv.transferableToJava("false", classOf[Boolean]).get() === false,
    conv.transferableToJava("true", classOf[Boolean]).get() === true,
    conv.transferableToJava(Short.MaxValue.toString, classOf[Short]).get() === Short.MaxValue,
    conv.transferableToJava(Short.MinValue.toString, classOf[Short]).get() === Short.MinValue,
    conv.transferableToJava(Int.MaxValue.toString, classOf[Int]).get() === Int.MaxValue,
    conv.transferableToJava(Int.MinValue.toString, classOf[Int]).get() === Int.MinValue,
    conv.transferableToJava(Long.MaxValue.toString, classOf[Long]).get() === Long.MaxValue,
    conv.transferableToJava(Long.MinValue.toString, classOf[Long]).get() === Long.MinValue,
    conv.transferableToJava(Float.MaxValue.toString, classOf[Float]).get() === Float.MaxValue,
    conv.transferableToJava(Float.MinValue.toString, classOf[Float]).get() === Float.MinValue,
    conv.transferableToJava(Double.MaxValue.toString, classOf[Double]).get() === Double.MaxValue,
    conv.transferableToJava(Double.MinValue.toString, classOf[Double]).get() === Double.MinValue,
    // Map
    reversible(Map("A" -> 0, 10 -> "X")),
    // Seq
    reversible(Seq("A", 0, 10, "X")),
    // List
    reversible(List("A", 0, 10, "X")),
    // Set
    reversible(Set("A", 0, 10, "X")),
    // Tuple
    reversible(new T0()),
    reversible(new T1(300)),
    reversible(new T2(-999, "Z")),
    // case class and scala tuple
    reversible(CT0()),
    reversible(CT1(943)),
    reversible(CT2(953, "I/O")),
    // reversible(()),
    reversible((999)),
    reversible((433, "ZZZ"))
  ).reduce(_ and _)

  val RandomUUID = UUID.randomUUID()

  val True = true must beTrue

  def reversible[T](value:T, `type`:Class[_ <: T])(cmp:(T, T) => Result):Result = {
    cmp(conv.transferableToJava(conv.javaToTransferable(value).get(), `type`).get(), value)
  }

  def reversible(value:Seq[Any]):Result = {
    reversible(value, classOf[Seq[Any]]) { (a:Seq[Any], b:Seq[Any]) =>
      (a.length === b.length) and a.zip(b).map { t => t._1 === t._2 }.fold(True) {
        _ and _
      }
    }
  }

  def reversible(value:List[Any]):Result = {
    reversible(value, classOf[List[Any]]) { (a:List[Any], b:List[Any]) =>
      (a.length === b.length) and a.zip(b).map { t => t._1 === t._2 }.fold(True) {
        _ and _
      }
    }
  }

  def reversible(value:Set[Any]):Result = {
    reversible(value, classOf[Set[Any]]) { (a:Set[Any], b:Set[Any]) => a.&~(b).isEmpty must beTrue }
  }

  def reversible(value:Map[Any, _]):Result = {
    reversible(value, classOf[Map[Any, _]]) { (a:Map[Any, _], b:Map[Any, _]) =>
      (a.keys.toSet.&~(b.keys.toSet).isEmpty must beTrue) and
        a.keys.map { k:Any => a(k) === b(k) }.fold(True) {
          _ and _
        }
    }
  }

  def reversible(value:Tuple):Result = {
    reversible(value, value.getClass) { (a:Tuple, b:Tuple) =>
      (a.count() === b.count()) and (a.schema() === b.schema()) and
        (0 until a.count()).map { i => a.valueAt(i) === b.valueAt(i) }.fold(True) {
          _ and _
        }
    }
  }

  def reversible(value:Product):Result = {
    reversible(value, value.getClass) { (a:Product, b:Product) => a === b }
  }

  def e8:Result = Seq[Result](
    {
      // パラメータなしのタプルへの変換
      val t = new Tuple {
        override def count():Int = 0

        override def schema():String = ""

        override def valueAt(i:Int):AnyRef = ???
      }
      conv.transferableToJava(t, classOf[T0]).get().isInstanceOf[T0] must beTrue
    }, {
      // パラメータ数の一致しないタプルへの変換
      val t = new Tuple {
        override def count():Int = 1

        override def schema():String = ""

        override def valueAt(i:Int):AnyRef = Int.box(i)
      }
      conv.transferableToJava(t, classOf[T0]).get() must throwA[CodecException]
    }, {
      // 型の一致しないタプルへの変換
      val t = new Tuple {
        override def count():Int = 1

        override def schema():String = ""

        override def valueAt(i:Int):AnyRef = "this is string"
      }
      conv.transferableToJava(t, classOf[T1]).get() must throwA[CodecException]
    }, {
      // パラメータ数と型の一致するタプルへの変換 1
      val t = new Tuple {
        override def count():Int = 1

        override def schema():String = ""

        override def valueAt(i:Int):AnyRef = Int.box(i)
      }
      val t1 = conv.transferableToJava(t, classOf[T1]).get()
      (t1.isInstanceOf[T1] must beTrue) and (t1.field1 === t.valueAt(0))
    }, {
      // パラメータ数と型の一致するタプルへの変換 2
      val f0 = random.nextInt()
      val f1 = random.alphanumeric.take(10).mkString
      val t = new Tuple {
        override def count():Int = 2

        override def schema():String = ""

        override def valueAt(i:Int):AnyRef = if(i == 0) Int.box(f0) else f1
      }
      val t2 = conv.transferableToJava(t, classOf[T2]).get()
      (t2.isInstanceOf[T2] must beTrue) and (t2.field1 === f0) and (t2.field2 === f1)
    }, {
      // スキームが有効なクラス名ではなく復元型が Tuple の場合は何もしない
      val f0 = random.nextInt()
      val f1 = random.alphanumeric.take(10).mkString
      val t = new Tuple {
        override def count():Int = 2

        override def schema():String = ""

        override def valueAt(i:Int):AnyRef = if(i == 0) Int.box(f0) else f1
      }
      val t1 = conv.transferableToJava(t, classOf[Tuple])
      t1 === t
    }, {
      // リモート指定のクラス (スキーム) がサブクラスの場合はそれで復元
      val f0 = random.nextInt()
      val f1 = random.alphanumeric.take(10).mkString
      val t = new Tuple {
        override def count():Int = 2

        override def schema():String = classOf[T2].getName

        override def valueAt(i:Int):AnyRef = if(i == 0) Int.box(f0) else f1
      }
      val t1 = conv.transferableToJava(t, classOf[T1]).get()
      (t1.isInstanceOf[T2] must beTrue) and (t1.field1 === f0) and (t1.asInstanceOf[T2].field2 === f1)
    }
  ).reduce {
    _ and _
  }

  val random = new Random()

}

class T0 extends Tuple {
  override def count():Int = 0

  override def schema():String = ""

  override def valueAt(i:Int):AnyRef = None
}

class T1(val field1:Int) extends Tuple {
  override def count():Int = 1

  override def schema():String = ""

  override def valueAt(i:Int):AnyRef = Int.box(field1)
}

class T2(field1:Int, val field2:String) extends T1(field1) {
  override def count():Int = 2

  override def schema():String = ""

  override def valueAt(i:Int):AnyRef = if(i == 0) Int.box(field1) else field2
}

case class CT0()

case class CT1(x:Int)

case class CT2(x:Int, y:String)